rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    // --- From: auth.rules ---
// Funções relacionadas à autenticação
function isSignedIn() {
  return request.auth != null;
}

function isUser(userId) {
  return isSignedIn() && request.auth.uid == userId;
}

function isAdmin() {
    return isSignedIn() && get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'ADMIN';
}

// Outras funções de checagem de perfil poderiam vir aqui
// Ex: function isAdmin() { ... }

    // --- From: validation.rules ---
// Funções de validação de dados
function isString(value) {
  return value is string;
}

function isNumber(value) {
  return value is number;
}

function isBoolean(value) {
  return value is bool;
}

    // From: articles.rules
match /articles/{articleId} {
  // Qualquer um pode ler artigos publicados.
  allow read: if resource.data.status == 'published';

  // Apenas administradores podem criar, atualizar ou deletar.
  allow write: if isSignedIn() && isAdmin();
}

    // From: battlePlans.rules
match /battlePlans/{planId} {
  allow read: if isSignedIn() && (resource.data.status == 'PUBLISHED' || resource.data.creatorId == request.auth.uid);
  allow create: if isSignedIn();
  allow update, delete: if isSignedIn() && resource.data.creatorId == request.auth.uid;
}

    // From: congregations.rules
match /congregations/{congregationId} {
  allow read: if isSignedIn();
  allow create: if isSignedIn(); // A lógica de quem pode criar é tratada na cloud function
  allow update: if isSignedIn() && request.auth.uid in resource.data.admins;
  
  match /members/{userId} {
    allow read: if isSignedIn();
    allow create: if isUser(userId); // Usuário solicita para entrar
    allow update: if (isUser(userId) && request.resource.data.keys().hasAll(['status'])) || (request.auth.uid in get(/databases/$(database)/documents/congregations/$(congregationId)).data.admins);
    allow delete: if isUser(userId) || (request.auth.uid in get(/databases/$(database)/documents/congregations/$(congregationId)).data.admins);
  }
  
  match /posts/{postId} {
    allow read: if isSignedIn() && get(/databases/$(database)/documents/congregations/$(congregationId)/members/$(request.auth.uid)).data.status in ['MEMBER', 'ADMIN'];
    allow create: if isSignedIn() && get(/databases/$(database)/documents/congregations/$(congregationId)/members/$(request.auth.uid)).data.status in ['MEMBER', 'ADMIN'] && request.resource.data.authorId == request.auth.uid;
    allow update, delete: if isSignedIn() && resource.data.authorId == request.auth.uid;
    
    match /comments/{commentId} {
       allow read: if isSignedIn() && get(/databases/$(database)/documents/congregations/$(congregationId)/members/$(request.auth.uid)).data.status in ['MEMBER', 'ADMIN'];
       allow create: if isSignedIn() && get(/databases/$(database)/documents/congregations/$(congregationId)/members/$(request.auth.uid)).data.status in ['MEMBER', 'ADMIN'] && request.resource.data.authorId == request.auth.uid;
       allow update, delete: if isSignedIn() && resource.data.authorId == request.auth.uid;
    }
    
    match /likes/{userId} {
       allow read: if isSignedIn() && get(/databases/$(database)/documents/congregations/$(congregationId)/members/$(request.auth.uid)).data.status in ['MEMBER', 'ADMIN'];
       allow create, delete: if isUser(userId);
    }
  }
}

    // From: content.rules
match /content/{contentId} {
  // Permitir leitura se o conteúdo estiver publicado
  allow get: if resource.data.status == 'PUBLISHED';
  // Permitir que qualquer um liste, contanto que filtre por 'PUBLISHED'
  allow list: if request.query.get("status") == "PUBLISHED";
  
  // Apenas administradores podem criar, atualizar e deletar
  allow write: if isSignedIn() && isAdmin();
}

    // From: feelingJourneys.rules
match /feelingJourneys/{journeyId} {
  allow read, write: if isSignedIn() && request.resource.data.userId == request.auth.uid;
}

    // From: journals.rules
match /journals/{entryId} {
  allow read, write: if isSignedIn() && request.resource.data.userId == request.auth.uid;
}

    // From: missionLogs.rules
match /missionLogs/{logId} {
  allow read, write: if isSignedIn() && request.resource.data.userId == request.auth.uid;
}

    // From: notifications.rules
match /notifications/{notificationId} {
    allow read, write: if isSignedIn() && request.auth.uid == request.resource.data.recipientId;
}

    // From: prayerCircles.rules
match /prayerCircles/{circleId} {
  allow read: if resource.data.isPublic == true || request.auth.uid in resource.data.members;
  allow create: if isSignedIn();
  allow update: if isSignedIn() && request.auth.uid == resource.data.createdBy;
  allow delete: if isSignedIn() && request.auth.uid == resource.data.createdBy;
}

    // From: prayers.rules
match /prayers/{prayerId} {
    // A oração é privada para o usuário que a fez.
    allow read, write: if isSignedIn() && request.resource.data.userId == request.auth.uid;
}

    // From: sharedArmors.rules
match /sharedArmors/{armorId} {
    allow read: if isSignedIn();
    allow create: if isSignedIn() && request.resource.data.userId == request.auth.uid;
    allow update, delete: if resource.data.userId == request.auth.uid;
}

    // From: sharedContent.rules
match /sharedContent/{contentId} {
    // Qualquer pessoa com o link pode ler o conteúdo
    allow read: true;
    
    // Apenas o criador pode criar ou deletar (soft delete)
    allow create: if isSignedIn() && request.resource.data.creatorId == request.auth.uid;
    allow update: if isSignedIn() && resource.data.creatorId == request.auth.uid;
    // Ninguém pode deletar permanentemente
    allow delete: if false;
}

    // From: studies.rules
match /studies/{studyId} {
    // Regra específica para 'get': qualquer um pode ler um estudo publicado.
    allow get: if resource.data.status == 'PUBLISHED';
    // Regra específica para 'list': qualquer um pode listar estudos, mas a query DEVE ter o filtro `where('status', '==', 'PUBLISHED')`.
    allow list: if request.query.get('status') == 'PUBLISHED';
    
    // Apenas admins podem criar, editar ou deletar estudos.
    allow write: if isSignedIn() && isAdmin();
}

    // From: suggestions.rules
match /suggestions/{suggestionId} {
    allow create: if isSignedIn();
    allow read, write: if isSignedIn() && isAdmin();
}

    // From: userPushTokens.rules
match /userPushTokens/{token} {
    // O usuário só pode criar/atualizar seu próprio token.
    allow write: if isSignedIn() && request.resource.data.userId == request.auth.uid;
    // Ninguém pode ler os tokens (exceto via funções de admin).
    allow read: if false;
}

    // From: users.rules
match /users/{userId} {
  // Qualquer usuário autenticado pode ler perfis (para ver nomes/fotos).
  allow read: if isSignedIn();
  
  // Um usuário só pode escrever em seu próprio perfil.
  // Um administrador pode escrever no perfil de qualquer usuário.
  allow write: if isUser(userId) || isAdmin();
  
  match /plans/{planId} {
  	 allow read, write: if isUser(userId);
  }

  match /armors/{armorId} {
      allow read, write: if isUser(userId);
  }
  
   match /battlePlans/{userPlanId} {
      allow read, write: if isUser(userId);
   }

  match /messages/{messageId} {
    allow read, write: if isUser(userId);
  }
}

    // From: victories.rules
match /victories/{victoryId} {
    // Qualquer um pode ler as vitórias (são públicas)
    allow read: true;

    // Apenas o criador do círculo de oração pode registrar uma vitória
    // (A validação de que o `recordedBy` é o criador do círculo é feita via lógica de segurança na aplicação)
    allow create: if isSignedIn();

    // Apenas quem registrou a vitória pode editar ou deletar.
    allow update, delete: if isSignedIn() && resource.data.recordedBy == request.auth.uid;
}

  }
}